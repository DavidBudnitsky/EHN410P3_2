# David Budnitsky
# 20453508

from u20453508_Prac_3_Backend import *
import numpy as np

# These values are from https://stackoverflow.com/questions/287871/how-do-i-print-colored-text-to-the-terminal
HEADER = '\033[95m'
OKBLUE = '\033[94m'
OKCYAN = '\033[96m'
OKGREEN = '\033[92m'
WARNING = '\033[93m'
FAIL = '\033[91m'
ENDC = '\033[0m'
BOLD = '\033[1m'
UNDERLINE = '\033[4m'

np.set_printoptions(threshold=np.inf)


def isPrime(num: int) -> bool:
    if num == 1:
        return False
    if num == 2:
        return True
    for k in range(2, num // 2 + 1):
        if np.gcd(k, num) != 1:
            return False
    return True


# def transmitMessage(message: np.ndarray) -> np.ndarray:
#     number = np.random.randint(0, 10)
#     if number == 5:
#         errorBytes = message[0:4]
#         errorBytes = [bin(k)[2:].zfill(8) for k in errorBytes]
#         errorPos = np.random.randint()


receiver = Receiver()
transmitter = Transmitter()

print(f"{HEADER}Welcome to Dodgy Dave's Dubious Digital Deception.{ENDC}\nLet's get started!\n\n")
print("To initialise a secure transmission channel, please give us the following: ")
p_input = input(f"{OKBLUE}RECEIVER{ENDC} p value, a good choice is 23:")
q_input = input(f"{OKBLUE}RECEIVER{ENDC} q value, a good choice is 3449:")

if p_input:
    p = int(p_input)
else:
    p = 23

if q_input:
    q = int(q_input)
else:
    q = 3449

if (not isPrime(p)) or (not isPrime(q)) or ((p * q) < int(2 ** 16 - 1)):
    print(f"{FAIL}A condition has been violated, setting p and q to 23 and 3449 respectively.{ENDC}")
    p = 23
    q = 3449

receiver.generate_RSA_Keys(p, q)

print(f"{OKCYAN}\n\nPHASE 1\n\n{ENDC}")

print(receiver.printRec())
publicKey = receiver.publicKey

RC4_K = input(f"{OKGREEN}TRANSMITTER{ENDC} Enter the RC4 Key: ")
if not (RC4_K):
    print("Nothing entered, setting key to random thing.")
    RC4_K = "qwertyuio"
if len(RC4_K) % 2 == 1:
    print("To encrpyt the key, it must have an even number of bytes, adding a pad to the key.")
    RC4_K = "0" + RC4_K

RC4_Khex = sha_String_To_Hex(RC4_K)
RC4_K_enc = transmitter.encrypt_With_RSA(RC4_Khex, publicKey)
RC4_K_dec = receiver.decrypt_With_RSA(RC4_K_enc, receiver.privateKey)

print(f"{OKGREEN}TRANSMITTER{ENDC} RC4 Key in hex: {RC4_Khex}")
print(f"{OKGREEN}TRANSMITTER{ENDC} RC4 Key (encrypted): {RC4_K_enc}")
print(f"{OKBLUE}RECEIVER{ENDC} RC4 Key (decrypted): {RC4_K_dec}")

print(f"{OKCYAN}\n\nPHASE 2\n\n{ENDC}")

M = input(f"{OKGREEN}TRANSMITTER{ENDC} Enter a message: ")
if (not M):
    print(f"{FAIL}\nYou should have entered a valid message!\n{ENDC}")
    M = "In cryptography, encryption is the process of encoding " \
        "information. This process converts the original representation of the information, known as plaintext, " \
        "into an alternative form known as ciphertext. Ideally, only authorized parties can decipher a ciphertext " \
        "back to plaintext and access the original information. Encryption does not itself prevent interference but " \
        "denies the intelligible content to a would-be interceptor. For technical reasons, an encryption scheme " \
        "usually uses a pseudo-random encryption key generated by an algorithm. It is possible to decrypt the message " \
        "without possessing the key but, for a well-designed encryption scheme, considerable computational resources " \
        "and skills are required. An authorized recipient can easily decrypt the message with the key provided by the " \
        "originator to recipients but not to unauthorized users. Historically, various forms of encryption have been " \
        "used to aid in cryptography. Early encryption techniques were often used in military messaging. Since then, " \
        "new techniques have emerged and become commonplace in all areas of modern computing.Modern encryption " \
        "schemes use the concepts of public-key and symmetric-key. Modern encryption techniques ensure security " \
        "because modern computers are inefficient at cracking the encryption. This text was taken from wikipedia."
print(f"{OKGREEN}TRANSMITTER: {ENDC}Message is \n{M}")
PM_hex = sha_String_To_Hex(M)
PM_hash = sha_Calculate_Hash(PM_hex)
P_Digest = PM_hex + PM_hash
C_digest = transmitter.encrypt_with_RC4(P_Digest, RC4_K)
print(f"{OKGREEN}TRANSMITTER: {ENDC}Plaintext message: \n{PM_hex}")
print(f"{OKGREEN}TRANSMITTER: {ENDC}Plaintext hash: \n{PM_hash}")
print(f"{OKGREEN}TRANSMITTER: {ENDC}Plaintext digest: \n{P_Digest}")
print(f"{OKGREEN}TRANSMITTER: {ENDC}Ciphertext digest: \n{C_digest}")

print(f"{OKCYAN}\n\nPHASE 3\n\n{ENDC}")

print(f"{OKBLUE}RECEIVER{ENDC} RC4 Key (decrypted): {RC4_K_dec}")
print(f"{OKBLUE}RECEIVER{ENDC} RC4 Key (decrypted): {RC4_K_dec}")

